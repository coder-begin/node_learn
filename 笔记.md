* 1.模块引入方式
```
文件引入方式:
1.内置模块
2.以. 或者..或者绝对路径引入的模块
3.只有模块名
 内置模块直接就是启动时候编译好的,直接引入执行
 以., .., 绝对路径开头的模块先找到在编译在执行(对于之前引入的魔窟嗲会存在缓存中,下次直接从缓存中找)
 没有路径的模块会从当前目录下的node_modules目录开始找,再到父级node_modules一直找到更目录下node_modules，所以很慢
```
* 对于模块的查找方式
```
没有文件名的会按照.js->.json->.node的顺序补全名字在查找
对于补全还是找不到的会查找这是不是一个包名,如果是包名就会分析包下面的package.json文件中的main 字段的名字进行补全查找,如果没有package.json或者没有main字段,就会查找index补全查找,如果都没有就会报错

```

* module对象:
```
function Module(id,parent){
    this.id=id;
    this.exports={};
    this.parent=parent;
    if(parent&&parent.children){
        parent.children.push(this)
    }
    this.filename=null;
    this.loaded=false;
    this.children=[];
}

```
* 对于模块的解析
```
.js文件调用fs加载编译执行
.node文件(这是c/c++编写的扩展模块),用dlopen加载编译好的文件
.json用fs读取用JSON.parse解析
别的按照.js处理
```
* 扩展文件解析
```
可以通过require.extensions['扩展名']=functon(){}来扩展文件的解析方式(不建议)
```
* 
